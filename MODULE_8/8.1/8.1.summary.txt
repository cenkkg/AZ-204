1/10/1 ---------------------------------------------------------------------------------------------------------------------
INTRODUCTION

2/10/1 ---------------------------------------------------------------------------------------------------------------------
Discover the API Management service...

API Management components...
Azure API Management is made up of an API gateway, a management plane, and a developer portal.

    + The API gateway is the endpoint that:
        ++ Accepts API calls and routes them to appropriate backends
        ++ Verifies API keys and other credentials presented with requests
        ++ Enforces usage quotas and rate limits
        ++ Caches responses to improve response latency and minimize the load on backend services
        ++ 
    + The management plane is the administrative interface where you set up your API program. Use it to:
        ++ Provision and configure API Management service settings
        ++ Define or import API schema
        ++ Package APIs into products
        ++ Manage users
    + The Developer portal is an automatically generated, fully customizable website with the documentation of your APIs.
        ++ Read API documentation
        ++ Call an API via the interactive console
        ++ Create an account and subscribe to get API keys

Products...
    Products are how APIs are surfaced to developers.
    Products in API Management have one or more APIs, and are configured with a title, description, and terms of use.
    Products can be Open or Protected. Protected products must be subscribed to before they can be used, while open products can be used without a subscription.

Groups...
    Groups are used to manage the visibility of products to developers.
        + Administrators - Manage API Management service instances and create the APIs, operations, and products that are used by developers.
            Azure subscription administrators are members of this group.
        + Developers - Authenticated developer portal users that build applications using your APIs.
            Developers are granted access to the developer portal and build applications that call the operations of an API.
        + Guests - Unauthenticated developer portal users. They can be granted certain read-only access, like the ability to view APIs but not call them.

3/10/1 ---------------------------------------------------------------------------------------------------------------------
Explore API gateways...

!!!
    The API Management gateway (also called data plane or runtime) is the service component that's responsible 
        for proxying API requests, applying policies, and collecting telemetry.
    An API gateway sits between clients and services. It acts as a reverse proxy, routing requests from clients to services. It may also perform various cross-cutting tasks such as authentication, SSL termination, and rate limiting.
!!!

If you don't deploy a gateway, clients must send requests directly to back-end services. However, there are some potential problems with exposing services directly to clients:
    - It can result in complex client code. The client must keep track of multiple endpoints, and handle failures in a resilient way.
    - It creates coupling between the client and the backend.
    - A single operation might require calls to multiple services.
    - Each public-facing service must handle concerns such as authentication, SSL, and client rate limiting.

Managed and self-hosted...
    API Management offers both managed and self-hosted gateways:
        + Managed - The managed gateway is the default gateway component that is deployed in Azure for every API Management instance in every service tier.
        + Self-hosted - The self-hosted gateway is an optional, containerized version of the default managed gateway. It's useful for hybrid and multicloud scenarios where there's a requirement to run the gateways off of Azure in the same environments where API backends are hosted.

4/10/1 ---------------------------------------------------------------------------------------------------------------------
Explore API Management policies...

In Azure API Management, policies allow the publisher to change the behavior of the API through configuration. 
Policies are applied inside the gateway that sits between the API consumer and the managed API. The gateway receives all requests and usually forwards them unaltered to the underlying API.

Understanding policy configuration...
The policy definition is a simple XML document that describes a sequence of inbound and outbound statements.
E.g.:
    """
        <policies>
        <inbound>
            <!-- statements to be applied to the request go here -->
        </inbound>
        <backend>
            <!-- statements to be applied before the request is forwarded to 
                the backend service go here -->
        </backend>
        <outbound>
            <!-- statements to be applied to the response go here -->
        </outbound>
        <on-error>
            <!-- statements to be applied if there is an error condition go here -->
        </on-error>
        </policies>
    """

If there's an error during the processing of a request, 
    any remaining steps in the inbound, backend, or outbound sections 
    are skipped and execution jumps to the statements in the on-error section. 

Policy expressions...
Unless the policy specifies otherwise, policy expressions can be used as attribute values or text values in any of the API Management policies.
A policy expression is either:
    + a single C# statement enclosed in @(expression)
    + a multi-statement C# code block, enclosed in @{expression}, that returns a value

E.g.:
    """
        <policies>
            <inbound>
                <base />
                <set-header name="x-request-context-data" exists-action="override">
                    <value>@(context.User.Id)</value>
                    <value>@(context.Deployment.Region)</value>
            </set-header>
            </inbound>
        </policies>
    """

Apply policies specified at different scopes...
If you have a policy at the global level and a policy configured for an API, then whenever that particular API is used both policies are applied.

Filter response content...
The policy defined in following example demonstrates how to filter
    data elements from the response payload based on the product associated with the request.

    """
        <policies>
            <inbound>
                <base />
            </inbound>
            <backend>
                <base />
            </backend>
            <outbound>
                <base />
                <choose>
                <when condition="@(context.Response.StatusCode == 200 && context.Product.Name.Equals("Starter"))">
                    <!-- NOTE that we are not using preserveContent=true when deserializing response body stream into a JSON object since we don't intend to access it again. See details on https://learn.microsoft.com/azure/api-management/api-management-transformation-policies#SetBody -->
                    <set-body>
                    @{
                        var response = context.Response.Body.As<JObject>();
                        foreach (var key in new [] {"minutely", "hourly", "daily", "flags"}) {
                        response.Property (key).Remove ();
                    }
                    return response.ToString();
                    }
                </set-body>
                </when>
                </choose>    
            </outbound>
            <on-error>
                <base />
            </on-error>
        </policies>
    """


5/10/1 ---------------------------------------------------------------------------------------------------------------------

